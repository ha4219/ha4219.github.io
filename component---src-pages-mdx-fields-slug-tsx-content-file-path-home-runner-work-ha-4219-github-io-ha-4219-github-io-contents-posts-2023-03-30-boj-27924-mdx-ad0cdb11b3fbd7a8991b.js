"use strict";(self.webpackChunkha4219_github_io=self.webpackChunkha4219_github_io||[]).push([[245],{4602:function(e,t,a){a.r(t),a.d(t,{PostTemplate:function(){return o},default:function(){return E}});var n=a(1151),l=a(7294);function m(e){const t=Object.assign({h1:"h1",p:"p",a:"a",h2:"h2",span:"span",math:"math",semantics:"semantics",mrow:"mrow",mi:"mi",annotation:"annotation",mo:"mo",mn:"mn",ol:"ol",li:"li",div:"div",pre:"pre",code:"code",ul:"ul"},(0,n.ah)(),e.components);return l.createElement(l.Fragment,null,l.createElement(t.h1,null,"윤이는 엄청난 것을 훔쳐갔습니다."),"\n",l.createElement(t.p,null,l.createElement(t.a,{href:"https://www.acmicpc.net/problem/27924"},"27924번: 윤이는 엄청난 것을 훔쳐갔습니다")),"\n",l.createElement(t.p,null,"UDPC G번 문제로 그래프에서 정점 위치별 거리를 파악하면 되는 문제이다. 간단하지만 하나의 아이디어로 시간복잡도를 줄일 수 있기에 글을 써본다."),"\n",l.createElement(t.h2,null,"문제 설명"),"\n",l.createElement(t.p,null,"정점 ",l.createElement(t.span,{className:"math math-inline"},l.createElement(t.span,{className:"katex"},l.createElement(t.span,{className:"katex-mathml"},l.createElement(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML"},l.createElement(t.semantics,null,l.createElement(t.mrow,null,l.createElement(t.mi,null,"N")),l.createElement(t.annotation,{encoding:"application/x-tex"},"N")))),l.createElement(t.span,{className:"katex-html","aria-hidden":"true"},l.createElement(t.span,{className:"base"},l.createElement(t.span,{className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),l.createElement(t.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"}},"N"))))),"개의 정점이 주어지고 ",l.createElement(t.span,{className:"math math-inline"},l.createElement(t.span,{className:"katex"},l.createElement(t.span,{className:"katex-mathml"},l.createElement(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML"},l.createElement(t.semantics,null,l.createElement(t.mrow,null,l.createElement(t.mi,null,"N"),l.createElement(t.mo,null,"−"),l.createElement(t.mn,null,"1")),l.createElement(t.annotation,{encoding:"application/x-tex"},"N-1")))),l.createElement(t.span,{className:"katex-html","aria-hidden":"true"},l.createElement(t.span,{className:"base"},l.createElement(t.span,{className:"strut",style:{height:"0.76666em",verticalAlign:"-0.08333em"}}),l.createElement(t.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"}},"N"),l.createElement(t.span,{className:"mspace",style:{marginRight:"0.2222222222222222em"}}),l.createElement(t.span,{className:"mbin"},"−"),l.createElement(t.span,{className:"mspace",style:{marginRight:"0.2222222222222222em"}})),l.createElement(t.span,{className:"base"},l.createElement(t.span,{className:"strut",style:{height:"0.64444em",verticalAlign:"0em"}}),l.createElement(t.span,{className:"mord"},"1"))))),"개의 간선이 주어진다. ",l.createElement(t.span,{className:"math math-inline"},l.createElement(t.span,{className:"katex"},l.createElement(t.span,{className:"katex-mathml"},l.createElement(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML"},l.createElement(t.semantics,null,l.createElement(t.mrow,null,l.createElement(t.mi,null,"N"),l.createElement(t.mo,null,"+"),l.createElement(t.mn,null,"1")),l.createElement(t.annotation,{encoding:"application/x-tex"},"N+1")))),l.createElement(t.span,{className:"katex-html","aria-hidden":"true"},l.createElement(t.span,{className:"base"},l.createElement(t.span,{className:"strut",style:{height:"0.76666em",verticalAlign:"-0.08333em"}}),l.createElement(t.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"}},"N"),l.createElement(t.span,{className:"mspace",style:{marginRight:"0.2222222222222222em"}}),l.createElement(t.span,{className:"mbin"},"+"),l.createElement(t.span,{className:"mspace",style:{marginRight:"0.2222222222222222em"}})),l.createElement(t.span,{className:"base"},l.createElement(t.span,{className:"strut",style:{height:"0.64444em",verticalAlign:"0em"}}),l.createElement(t.span,{className:"mord"},"1"))))),"번 라인에는 윤이, 달구 그리고 포닉스가 시작하는 위치가 주어지는데 각 노드의 위치에서 Leaf(간선의 개수가 1인)인 정점까지 도착하는 최단 거리를 측정한 뒤(거리는 dfs 또는 bfs 아무거나 써도 된다) 각 Leaf 노드를 돌면서 윤이의 거리가 두 명의 거리보다 짧다면 정답이 나온다.(거리가 같은 경우는 무슨 경우일까? 아래에서 확인해보자)"),"\n",l.createElement(t.h2,null,"예외 경우"),"\n",l.createElement(t.p,null,"이 부분을 생각을 조금 많이 했다. 거리가 짧은 경우만 확인해도 될까? 내가 생각한 경우가 부족할 수 있지만 생각한 내용들을 적어본다."),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,"cycle인 경우",l.createElement("br"),"\n문제에서 cycle에 대한 예외가 따로 없다. 그래서 생각해봤는데 Leaf 노드까지 가는 최단 거리로 가야하기 때문에 최선으로 갈 경우 cycle을 돌지 않을 것이다.(cycle을 돈다는 자체가 거리를 증가시키기 때문에 달구와 포닉스는 최단 거리로 갈 경우 윤이에게 이득이 될 것이 없다)"),"\n",l.createElement(t.li,null,"최단 거리가 같은 경우\n",l.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/599a5ac63c7ddd60cd4643b5b572aa99/a878e/Untitled.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAABRNAAAUTQGUyo0vAAABWklEQVR42q2Uga6CMAxF9//fqDFBg8EgIoKAgjWnSc0cG3l5scmyWdfb295RJ3+w1+ulyz+HPjMXBsaCQoBYzBdgjEHK5nmW5/Mp4zjqOSTiQofZNE3yeDw0kMV/fd/L7Xb7+GJMXegga1mWcr1e5X6/KyiMmqaRYRi+mFpCn+mCYdd1Cng6naSqqg8I/rqudcd/uVxkv9/LbrfTxFFAyqQsjJ3LBGIwAQy2WZbJ+XyW4/Eo2+1W9yigARFE1sPhoKUaQ78t3LEFkS/AsGzK5CICWMlryi9EialsTEwYSqSvfkITzAd1a48aQ216ttlsdLVtq8D4EY+2+DEuRd32oig0GCBUpqf2FmFKz+2dLj69EJSLsAAUte290QY7h3FJhgTAit95nmsPMXqG4qlB4dYmCyX5XwdgliSl/GrJ9tgBwoeqIVh02qyNsFiSfzNcm4mpMefkx/ZzwDe0ByoZWV50wwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="Untitled"\n        title="Untitled"\n        src="/static/599a5ac63c7ddd60cd4643b5b572aa99/37523/Untitled.png"\n        srcset="/static/599a5ac63c7ddd60cd4643b5b572aa99/e9ff0/Untitled.png 180w,\n/static/599a5ac63c7ddd60cd4643b5b572aa99/f21e7/Untitled.png 360w,\n/static/599a5ac63c7ddd60cd4643b5b572aa99/37523/Untitled.png 720w,\n/static/599a5ac63c7ddd60cd4643b5b572aa99/302a4/Untitled.png 1080w,\n/static/599a5ac63c7ddd60cd4643b5b572aa99/07a9c/Untitled.png 1440w,\n/static/599a5ac63c7ddd60cd4643b5b572aa99/a878e/Untitled.png 2048w"\n        sizes="(max-width: 720px) 100vw, 720px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}}),"\n같은 경우는 문제 원칙상 윤이가 Leaf에 도착하고 이후 달구 또는 포닉스가 그 뒤에 도착한다는 것이다. 이렇게 보면 맞는 것 같지만 Leaf 노드가 간선이 하나라는 점이 문제이다. 간선이 하나라는 것은 Leaf 노드로 가기 위해 통과해야하는 노드가 하나라는 것이다. 그러므로 같다라는 의미는 이전 노드에서 만난다라고 해석할 수 있다."),"\n"),"\n",l.createElement(t.h2,null,"원래 코드"),"\n",l.createElement(t.pre,null,l.createElement(t.code,{className:"language-cpp"},'\nusing namespace std;\n\nint n;\nint d1[N], d2[N], d3[N];\nint qs[3];\nvector<int> a[N];\nset<int> leaf;\n\nvoid dfs(int cur, int depth, int d[]) {\n\tif (a[cur].size() == 1) {\n\t\tleaf.insert(cur);\n\t}\n\tfor (auto nn : a[cur]) {\n\t\tif (d[nn] > depth + 1) {\n\t\t\td[nn] = depth + 1;\n\t\t\tdfs(nn, depth + 1, d);\n\t\t}\n\t}\n}\n\nvoid input() {\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tl--;\n\t\tr--;\n\t\ta[l].push_back(r);\n\t\ta[r].push_back(l);\n\t}\n\tfor (int i = 0; i < 3; i++) {\n\t\tcin >> qs[i];\n\t\tqs[i]--;\n\t}\n}\n\nint solve() {\n\tinput();\n\tfill_n(d1, n, MAX);\n\tfill_n(d2, n, MAX);\n\tfill_n(d3, n, MAX);\n\td1[qs[0]] = 0;\n\tdfs(qs[0], 0, d1);\n\td2[qs[1]] = 0;\n\tdfs(qs[1], 0, d2);\n\td3[qs[2]] = 0;\n\tdfs(qs[2], 0, d3);\n\tfor (auto q : leaf) {\n\t\tif (d1[q] < d2[q] && d1[q] < d3[q]) {\n\t\t\tcout << "YES\\n";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << "NO\\n";\n\treturn 0;\n}\n\nint main() {\n\tFAST;\n\tsolve();\n\n\treturn 0;\n}\n')),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"dfs로 문제를 해결했다."),"\n",l.createElement(t.li,null,"dfs를 3번 돌려서(윤이, 달구 그리고 포닉스) 각 위치별 최단 거리를 계산한 뒤(",l.createElement(t.span,{className:"math math-inline"},l.createElement(t.span,{className:"katex"},l.createElement(t.span,{className:"katex-mathml"},l.createElement(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML"},l.createElement(t.semantics,null,l.createElement(t.mrow,null,l.createElement(t.mn,null,"3"),l.createElement(t.mi,null,"N")),l.createElement(t.annotation,{encoding:"application/x-tex"},"3N")))),l.createElement(t.span,{className:"katex-html","aria-hidden":"true"},l.createElement(t.span,{className:"base"},l.createElement(t.span,{className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),l.createElement(t.span,{className:"mord"},"3"),l.createElement(t.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"}},"N"))))),") Leaf를 돌면서(",l.createElement(t.span,{className:"math math-inline"},l.createElement(t.span,{className:"katex"},l.createElement(t.span,{className:"katex-mathml"},l.createElement(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML"},l.createElement(t.semantics,null,l.createElement(t.mrow,null,l.createElement(t.mi,null,"N")),l.createElement(t.annotation,{encoding:"application/x-tex"},"N")))),l.createElement(t.span,{className:"katex-html","aria-hidden":"true"},l.createElement(t.span,{className:"base"},l.createElement(t.span,{className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),l.createElement(t.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"}},"N"))))),") 윤이의 최단거리가 둘 보다 짧은 Leaf를 찾는다."),"\n",l.createElement(t.li,null,"결국 총 ",l.createElement(t.span,{className:"math math-inline"},l.createElement(t.span,{className:"katex"},l.createElement(t.span,{className:"katex-mathml"},l.createElement(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML"},l.createElement(t.semantics,null,l.createElement(t.mrow,null,l.createElement(t.mn,null,"4"),l.createElement(t.mi,null,"N")),l.createElement(t.annotation,{encoding:"application/x-tex"},"4N")))),l.createElement(t.span,{className:"katex-html","aria-hidden":"true"},l.createElement(t.span,{className:"base"},l.createElement(t.span,{className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),l.createElement(t.span,{className:"mord"},"4"),l.createElement(t.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"}},"N"))))),"(입력 제외)로 문제를 해결할 것이다."),"\n",l.createElement(t.li,null,l.createElement(t.code,null,"set")," 으로 Leaf를 저장했지만 시간 복잡도 상 ",l.createElement(t.span,{className:"math math-inline"},l.createElement(t.span,{className:"katex"},l.createElement(t.span,{className:"katex-mathml"},l.createElement(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML"},l.createElement(t.semantics,null,l.createElement(t.mrow,null,l.createElement(t.mi,null,"N")),l.createElement(t.annotation,{encoding:"application/x-tex"},"N")))),l.createElement(t.span,{className:"katex-html","aria-hidden":"true"},l.createElement(t.span,{className:"base"},l.createElement(t.span,{className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),l.createElement(t.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"}},"N"))))),"에 수렴한 기대값이다."),"\n"),"\n",l.createElement(t.h2,null,"개선 코드"),"\n",l.createElement(t.pre,null,l.createElement(t.code,{className:"language-python"},"import enum\nfrom sys import stdin, maxsize, setrecursionlimit\nfrom heapq import *\nfrom bisect import *\nfrom collections import deque\nimport random\nfrom itertools import combinations\n\nMAX = 17\nMOD = 1000000007\nsetrecursionlimit(10**6)\ninput = stdin.readline\n\nN = int(input())\na =[[] for _ in range(N+1)]\n\nfor _ in range(N-1):\n    l, r = map(int, input().split())\n    a[l].append(r)\n    a[r].append(l)\n\nqs = list(map(int, input().split()))\n\ndef main():\n    # ( pos, isYun: 1=yun, 2=others)\n    q = deque([(qs[1], 2), (qs[2], 2), (qs[0], 1)])\n    v = [0] * (N + 1) # v is visited array\n    v[qs[0]] = 1;v[qs[1]] = 2;v[qs[2]] = 2\n    while q:\n        pos, is_yun = q.popleft()\n        if is_yun == 1 and len(a[pos]) == 1:\n            print('YES');return;\n        for nn in a[pos]: # nn is next_node\n            if not v[nn]:\n                v[nn] = is_yun\n                q.append((nn, is_yun))\n    print('NO');return;\n    \n\nif __name__ == '__main__':\n    main()\n")),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"굳이 ",l.createElement(t.span,{className:"math math-inline"},l.createElement(t.span,{className:"katex"},l.createElement(t.span,{className:"katex-mathml"},l.createElement(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML"},l.createElement(t.semantics,null,l.createElement(t.mrow,null,l.createElement(t.mn,null,"4"),l.createElement(t.mi,null,"N")),l.createElement(t.annotation,{encoding:"application/x-tex"},"4N")))),l.createElement(t.span,{className:"katex-html","aria-hidden":"true"},l.createElement(t.span,{className:"base"},l.createElement(t.span,{className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),l.createElement(t.span,{className:"mord"},"4"),l.createElement(t.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"}},"N"))))),"으로 문제를 해결해야 할까? 여기서 시작된 생각이다."),"\n",l.createElement(t.li,null,"이 문제를 bfs로 다시 접근했다."),"\n",l.createElement(t.li,null,"처음 시작 queue에 달구, 포닉스 그리고 윤이 순으로 넣었다.","\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"이유는 윤이가 첫번째로 들어갈 경우, 윤이의 어떤 노드까지 최단거리가 달구와 포닉스의 어떤 노드까지 최단거리와 같은 경우가 있기 때문이다."),"\n",l.createElement(t.li,null,"따라서 먼저 달구와 포닉스가 방문한 노드는 윤이 입장에서 밟을 수 없는 노드가 된다. (해당 노드를 통해 진행된 leaf 노드까지 거리가 윤이는 달구와 포닉스보다 작을 수 없다)"),"\n"),"\n"),"\n",l.createElement(t.li,null,"방문한 노드는 제외되기 때문에 전체 노드 개수 ",l.createElement(t.span,{className:"math math-inline"},l.createElement(t.span,{className:"katex"},l.createElement(t.span,{className:"katex-mathml"},l.createElement(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML"},l.createElement(t.semantics,null,l.createElement(t.mrow,null,l.createElement(t.mi,null,"N")),l.createElement(t.annotation,{encoding:"application/x-tex"},"N")))),l.createElement(t.span,{className:"katex-html","aria-hidden":"true"},l.createElement(t.span,{className:"base"},l.createElement(t.span,{className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),l.createElement(t.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"}},"N"))))),"만큼 while문이 진행될 것이다. 따라서 문제를 ",l.createElement(t.span,{className:"math math-inline"},l.createElement(t.span,{className:"katex"},l.createElement(t.span,{className:"katex-mathml"},l.createElement(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML"},l.createElement(t.semantics,null,l.createElement(t.mrow,null,l.createElement(t.mi,null,"N")),l.createElement(t.annotation,{encoding:"application/x-tex"},"N")))),l.createElement(t.span,{className:"katex-html","aria-hidden":"true"},l.createElement(t.span,{className:"base"},l.createElement(t.span,{className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),l.createElement(t.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"}},"N"))))),"으로 해결 할 수 있다."),"\n"))}var s=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,n.ah)(),e.components);return t?l.createElement(t,e,l.createElement(m,e)):m(e)},c=a(2968),r=a(3653),i=a(2356),p=a(3147);const o=e=>{var t;let{data:a,children:m,pageContext:s}=e;const{0:o,1:E}=(0,l.useState)(null),{siteUrl:d}=a.site.siteMetadata,h=s.fields__slug;return(0,l.useEffect)((()=>{if(!d||!h)return;const e=d.replace(/(^\w+:|^)\/\//,""),t=h.replace(/\//g,"");fetch("https://api.countapi.xyz/hit/"+e+"/"+t).then((e=>e.json())).then((e=>{let{value:t}=e;return E(t)})).catch((()=>E(0)))}),[d,h]),l.createElement(c.Z,null,l.createElement("div",{className:"mx-auto max-w-3xl"},l.createElement(i.Z,{title:a.mdx.frontmatter.title,view:o,author:a.mdx.frontmatter.author,date:a.mdx.frontmatter.date,minutes:a.mdx.fields.timeToRead.minutes}),l.createElement(n.Zo,{components:r.Z},m),l.createElement("div",{className:"flex flex-wrap break-words py-4"},null===(t=a.mdx.frontmatter.tags)||void 0===t?void 0:t.map((e=>l.createElement("span",{key:e,className:"my-1 mr-2 inline-block rounded-xl bg-gray-200 p-2 px-3 text-sm"},e)))),l.createElement(p.Z,null)))};function E(e){return l.createElement(o,e,l.createElement(s,e))}}}]);
//# sourceMappingURL=component---src-pages-mdx-fields-slug-tsx-content-file-path-home-runner-work-ha-4219-github-io-ha-4219-github-io-contents-posts-2023-03-30-boj-27924-mdx-ad0cdb11b3fbd7a8991b.js.map