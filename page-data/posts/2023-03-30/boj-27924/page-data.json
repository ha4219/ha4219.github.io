{"componentChunkName":"component---src-pages-mdx-fields-slug-tsx-content-file-path-home-runner-work-ha-4219-github-io-ha-4219-github-io-contents-posts-2023-03-30-boj-27924-mdx","path":"/posts/2023-03-30/boj-27924/","result":{"data":{"mdx":{"id":"9d2841c5-04dd-5819-99ac-666085b928a6","body":"\n# 윤이는 엄청난 것을 훔쳐갔습니다.\n\n[27924번: 윤이는 엄청난 것을 훔쳐갔습니다](https://www.acmicpc.net/problem/27924)\n\nUDPC G번 문제로 그래프에서 정점 위치별 거리를 파악하면 되는 문제이다. 간단하지만 하나의 아이디어로 시간복잡도를 줄일 수 있기에 글을 써본다.\n\n## 문제 설명\n\n정점 $N$개의 정점이 주어지고 $N-1$개의 간선이 주어진다. $N+1$번 라인에는 윤이, 달구 그리고 포닉스가 시작하는 위치가 주어지는데 각 노드의 위치에서 Leaf(간선의 개수가 1인)인 정점까지 도착하는 최단 거리를 측정한 뒤(거리는 dfs 또는 bfs 아무거나 써도 된다) 각 Leaf 노드를 돌면서 윤이의 거리가 두 명의 거리보다 짧다면 정답이 나온다.(거리가 같은 경우는 무슨 경우일까? 아래에서 확인해보자)\n\n## 예외 경우\n\n이 부분을 생각을 조금 많이 했다. 거리가 짧은 경우만 확인해도 될까? 내가 생각한 경우가 부족할 수 있지만 생각한 내용들을 적어본다.\n\n1. cycle인 경우<br/>\n    문제에서 cycle에 대한 예외가 따로 없다. 그래서 생각해봤는데 Leaf 노드까지 가는 최단 거리로 가야하기 때문에 최선으로 갈 경우 cycle을 돌지 않을 것이다.(cycle을 돈다는 자체가 거리를 증가시키기 때문에 달구와 포닉스는 최단 거리로 갈 경우 윤이에게 이득이 될 것이 없다)\n2. 최단 거리가 같은 경우\n    ![Untitled](boj-27924/Untitled.png)\n    같은 경우는 문제 원칙상 윤이가 Leaf에 도착하고 이후 달구 또는 포닉스가 그 뒤에 도착한다는 것이다. 이렇게 보면 맞는 것 같지만 Leaf 노드가 간선이 하나라는 점이 문제이다. 간선이 하나라는 것은 Leaf 노드로 가기 위해 통과해야하는 노드가 하나라는 것이다. 그러므로 같다라는 의미는 이전 노드에서 만난다라고 해석할 수 있다.\n    \n\n## 원래 코드\n\n```cpp\n\nusing namespace std;\n\nint n;\nint d1[N], d2[N], d3[N];\nint qs[3];\nvector<int> a[N];\nset<int> leaf;\n\nvoid dfs(int cur, int depth, int d[]) {\n\tif (a[cur].size() == 1) {\n\t\tleaf.insert(cur);\n\t}\n\tfor (auto nn : a[cur]) {\n\t\tif (d[nn] > depth + 1) {\n\t\t\td[nn] = depth + 1;\n\t\t\tdfs(nn, depth + 1, d);\n\t\t}\n\t}\n}\n\nvoid input() {\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tl--;\n\t\tr--;\n\t\ta[l].push_back(r);\n\t\ta[r].push_back(l);\n\t}\n\tfor (int i = 0; i < 3; i++) {\n\t\tcin >> qs[i];\n\t\tqs[i]--;\n\t}\n}\n\nint solve() {\n\tinput();\n\tfill_n(d1, n, MAX);\n\tfill_n(d2, n, MAX);\n\tfill_n(d3, n, MAX);\n\td1[qs[0]] = 0;\n\tdfs(qs[0], 0, d1);\n\td2[qs[1]] = 0;\n\tdfs(qs[1], 0, d2);\n\td3[qs[2]] = 0;\n\tdfs(qs[2], 0, d3);\n\tfor (auto q : leaf) {\n\t\tif (d1[q] < d2[q] && d1[q] < d3[q]) {\n\t\t\tcout << \"YES\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"NO\\n\";\n\treturn 0;\n}\n\nint main() {\n\tFAST;\n\tsolve();\n\n\treturn 0;\n}\n```\n\n- dfs로 문제를 해결했다.\n- dfs를 3번 돌려서(윤이, 달구 그리고 포닉스) 각 위치별 최단 거리를 계산한 뒤($3N$) Leaf를 돌면서($N$) 윤이의 최단거리가 둘 보다 짧은 Leaf를 찾는다.\n- 결국 총 $4N$(입력 제외)로 문제를 해결할 것이다.\n- `set` 으로 Leaf를 저장했지만 시간 복잡도 상 $N$에 수렴한 기대값이다.\n\n## 개선 코드\n\n```python\nimport enum\nfrom sys import stdin, maxsize, setrecursionlimit\nfrom heapq import *\nfrom bisect import *\nfrom collections import deque\nimport random\nfrom itertools import combinations\n\nMAX = 17\nMOD = 1000000007\nsetrecursionlimit(10**6)\ninput = stdin.readline\n\nN = int(input())\na =[[] for _ in range(N+1)]\n\nfor _ in range(N-1):\n    l, r = map(int, input().split())\n    a[l].append(r)\n    a[r].append(l)\n\nqs = list(map(int, input().split()))\n\ndef main():\n    # ( pos, isYun: 1=yun, 2=others)\n    q = deque([(qs[1], 2), (qs[2], 2), (qs[0], 1)])\n    v = [0] * (N + 1) # v is visited array\n    v[qs[0]] = 1;v[qs[1]] = 2;v[qs[2]] = 2\n    while q:\n        pos, is_yun = q.popleft()\n        if is_yun == 1 and len(a[pos]) == 1:\n            print('YES');return;\n        for nn in a[pos]: # nn is next_node\n            if not v[nn]:\n                v[nn] = is_yun\n                q.append((nn, is_yun))\n    print('NO');return;\n    \n\nif __name__ == '__main__':\n    main()\n```\n\n- 굳이 $4N$으로 문제를 해결해야 할까? 여기서 시작된 생각이다.\n- 이 문제를 bfs로 다시 접근했다.\n- 처음 시작 queue에 달구, 포닉스 그리고 윤이 순으로 넣었다.\n    - 이유는 윤이가 첫번째로 들어갈 경우, 윤이의 어떤 노드까지 최단거리가 달구와 포닉스의 어떤 노드까지 최단거리와 같은 경우가 있기 때문이다.\n    - 따라서 먼저 달구와 포닉스가 방문한 노드는 윤이 입장에서 밟을 수 없는 노드가 된다. (해당 노드를 통해 진행된 leaf 노드까지 거리가 윤이는 달구와 포닉스보다 작을 수 없다)\n- 방문한 노드는 제외되기 때문에 전체 노드 개수 $N$만큼 while문이 진행될 것이다. 따라서 문제를 $N$으로 해결 할 수 있다.","excerpt":"27924번: 윤이는 엄청난 것을 훔쳐갔습니다 UDPC G번 문제로 그래프에서 정점 위치별 거리를 파악하면 되는 문제이다. 간단하지만 하나의 아이디어로 시간복잡도를 줄일 수 있기에 글을 써본다.\n\n문제 설명\n\n정점 NNN개의 정점이 주어지고 N−1N-1N−1개의 간선이 주어진다. N+1N+1N+1번 라인에는 윤이, 달구 그리고 포닉스가 시작하는 위치가 주어지는데 각 노드의 위치에서 Leaf(간선의 개수가 1인)인 정점까지 도착하는 최단 거리를 측정한 뒤(거리는 dfs 또는 bfs 아무거나 써도 된다) 각 Leaf 노드를 돌면서 윤이의 거리가 두 명의 거리보다 짧다면 정답이 나온다.(거리가 같은 경우는 무슨 경우일까? 아래에서 확인해보자)\n\n예외 경우\n\n이 부분을 생각을 조금 많이 했다. 거리가 짧은 경우만 확인해도 될까? 내가 생각한 경우가 부족할 수 있지만 생각한 내용들을 적어본다.\n\ncycle인 경우문제에서 cycle에 대한 예외가 따로 없다. 그래서 생각해봤는데 Leaf 노드까지…","frontmatter":{"date":"March 30, 2023","title":"윤이는 엄청난 것을 훔쳐갔습니다.","category":"algorithm","author":"ha4219","tags":["algorithm"],"thumbnail":null},"fields":{"slug":"/posts/2023-03-30/boj-27924/","timeToRead":{"minutes":6.055}}},"site":{"siteMetadata":{"siteUrl":"https://jeongdongha.me"}}},"pageContext":{"id":"9d2841c5-04dd-5819-99ac-666085b928a6","fields__slug":"/posts/2023-03-30/boj-27924/","__params":{"fields__slug":"posts"},"frontmatter":{"layout":"post","title":"윤이는 엄청난 것을 훔쳐갔습니다.","tags":["algorithm"],"category":"algorithm","date":"2023-03-30T00:00:00.000Z","author":"ha4219"}}},"staticQueryHashes":[],"slicesMap":{}}