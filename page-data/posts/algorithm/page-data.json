{"componentChunkName":"component---src-templates-category-tsx","path":"/posts/algorithm/","result":{"pageContext":{"currentCategory":"algorithm","categories":["All","algorithm","daily","review","devops","vision"],"edges":[{"node":{"frontmatter":{"title":"특별한 서빙","date":"2023-04-03T00:00:00.000Z","moment":"7 hours ago","thumbnail":null,"tags":["algorithm"],"category":"algorithm"},"excerpt":"27896번: 특별한 서빙 문제 설명\n\nNNN명의 학생들이 순서대로 xix_ixi​만큼의 값을 뺄지 아니면 더할지를 정하는데 해당 불만도의 총 합이 MMM이 넘어서는 안된다. 이때…","id":"0a2a2cb6-0b6e-51f5-b122-42c8374ca0eb","body":"\n# 특별한 서빙\n\n[27896번: 특별한 서빙](https://www.acmicpc.net/problem/27896)\n\n## 문제 설명\n\n$N$명의 학생들이 순서대로 $x_i$만큼의 값을 뺄지 아니면 더할지를 정하는데 해당 불만도의 총 합이 $M$이 넘어서는 안된다. 이때 $M$이하로 만들기 위해 최소 몇 번 빼야하는가\n\n## 잡담\n\n문제 이해가 조금 힘들었다. 길이는 짧은 데 이해가 안됐다.\n\n## 풀이\n\n이유는 모르겠지만 처음부터 그냥 그리디라고 생각했다. 그래서 생각을 구체화 시켰다. \n\n- $N$명의 불만도를 순차적으로 더하고 pq에 insert한다. ($O(N)$)\n    - 이때 $M$보다 불만도 값이 크다면 pq에서 가장 큰 값을 뽑아 2*$x_{pq}$ 값을 불만도에서 뺀다. $O(\\log N)$\n        - 여러번 pq에서 값을 빼야하는 상황이 있을까? → 없다.\n            - $sum_{i}=sum_{i-1}+x_i$\n            - if $sum_{i-1}+x_i >= M$\n                - $sum_{i}=sum_{i} - 2 \\times max(x_{0...i})$\n                - $x_i \\leq max(x_{0...i})$\n                - so $sum_{i}<M$\n\n그래서 $O(N\\log N)$이다.\n\n## 다른 방식\n\n다른 사람들한테 풀어보라고 했더니 2가지 방법을 얘기했다.\n\n1. combination<br/>\n    조합은 왜 안될까? 코드를 보지 못해서 정확한 접근은 못봤지만 조합이라는 키워드를 봤을 때 풀이는 최소 개수를 이항 계수로 두고 문제를 푸는 방법이다. 이는 완전탐색인데 $O(N\\times N!)$으로 보인다. 그러므로 불가능.\n2. Knapsack<br/>\n    일반적으로 d[학생의 index][불만도의 합]으로 두고 계산한다. 하지만 $N, M$ 값이 크기 때문에 성립할 수 없지만 작다고 생각하고 접근해보자.<br/>\n    ```cpp\n    // 사실 코드는 대충써서 틀린 거 같다. ㅋㅋ\n    int d[학생_index][불만도의 합] = 파묻튀 먹은 인원 수\n    for(int i=0;i<N;i++){\n    \tfor(int k=0;k<M;k++){\n    \t\tif (a[i] + k < M) { // 넣을 수 있을 때\n    \t\t\td[i][a[i] + k] = max(d[i-1][k], d[i][a[i] + k] + 1)\n    \t\t} else { // 넣을 수 없을 때\n    \t\t\t// 여기가 핵심인데 해당 부분은 현재 index가 i인 학생을 제외 시킨다.\n    \t\t\td[i][k] = d[i-1][k];\n    \t\t}\n    \t}\n    }\n    ```\n    해당 부분은 현재 index가 i인 학생을 제외 시킨다.<br/>\n    과연 이게 맞을까? 반례를 들겠다.<br/>\n    ```cpp\n    3 3\n    2 1 1\n    ans: 1\n    ```\n    위 코드는 냅색으로 접근한다면 처음에 2를 가져오고 1, 1 값을 버려서 최종 값으로 2를 출력할 것이다. (틀렸으면 말해 줘라.)<br/>\n    그러면 이부분을 pq를 이용해 최대로 큰 녀석을 빼서 계산한다면?<br/>\n    이전 for문이 필요 없게 된다. $O(NM\\log N)$을 통과시켜주는 문제는 없을 것이다.<br/>\n\n## 생각 정리\n\n글로 쓰다보니 조금 엉성하다. 좀 더 생각을 다듬고 글을 수정하겠다.","fields":{"timeToRead":{"minutes":3.565},"slug":"/posts/2023-04-03/boj-27896/"},"internal":{"contentFilePath":"/home/runner/work/ha4219.github.io/ha4219.github.io/contents/posts/2023-04-03/boj-27896.mdx"}},"next":{"fields":{"slug":"/posts/2023-03-30/boj-27924/"}},"previous":null},{"node":{"frontmatter":{"title":"윤이는 엄청난 것을 훔쳐갔습니다.","date":"2023-03-30T00:00:00.000Z","moment":"4 days ago","thumbnail":null,"tags":["algorithm"],"category":"algorithm"},"excerpt":"27924번: 윤이는 엄청난 것을 훔쳐갔습니다 UDPC G번 문제로 그래프에서 정점 위치별 거리를 파악하면 되는 문제이다. 간단하지만 하나의 아이디어로 시간복잡도를 줄일 수…","id":"9d2841c5-04dd-5819-99ac-666085b928a6","body":"\n# 윤이는 엄청난 것을 훔쳐갔습니다.\n\n[27924번: 윤이는 엄청난 것을 훔쳐갔습니다](https://www.acmicpc.net/problem/27924)\n\nUDPC G번 문제로 그래프에서 정점 위치별 거리를 파악하면 되는 문제이다. 간단하지만 하나의 아이디어로 시간복잡도를 줄일 수 있기에 글을 써본다.\n\n## 문제 설명\n\n정점 $N$개의 정점이 주어지고 $N-1$개의 간선이 주어진다. $N+1$번 라인에는 윤이, 달구 그리고 포닉스가 시작하는 위치가 주어지는데 각 노드의 위치에서 Leaf(간선의 개수가 1인)인 정점까지 도착하는 최단 거리를 측정한 뒤(거리는 dfs 또는 bfs 아무거나 써도 된다) 각 Leaf 노드를 돌면서 윤이의 거리가 두 명의 거리보다 짧다면 정답이 나온다.(거리가 같은 경우는 무슨 경우일까? 아래에서 확인해보자)\n\n## 예외 경우\n\n이 부분을 생각을 조금 많이 했다. 거리가 짧은 경우만 확인해도 될까? 내가 생각한 경우가 부족할 수 있지만 생각한 내용들을 적어본다.\n\n1. cycle인 경우<br/>\n    문제에서 cycle에 대한 예외가 따로 없다. 그래서 생각해봤는데 Leaf 노드까지 가는 최단 거리로 가야하기 때문에 최선으로 갈 경우 cycle을 돌지 않을 것이다.(cycle을 돈다는 자체가 거리를 증가시키기 때문에 달구와 포닉스는 최단 거리로 갈 경우 윤이에게 이득이 될 것이 없다)\n2. 최단 거리가 같은 경우\n    ![Untitled](boj-27924/Untitled.png)\n    같은 경우는 문제 원칙상 윤이가 Leaf에 도착하고 이후 달구 또는 포닉스가 그 뒤에 도착한다는 것이다. 이렇게 보면 맞는 것 같지만 Leaf 노드가 간선이 하나라는 점이 문제이다. 간선이 하나라는 것은 Leaf 노드로 가기 위해 통과해야하는 노드가 하나라는 것이다. 그러므로 같다라는 의미는 이전 노드에서 만난다라고 해석할 수 있다.\n    \n\n## 원래 코드\n\n```cpp\n\nusing namespace std;\n\nint n;\nint d1[N], d2[N], d3[N];\nint qs[3];\nvector<int> a[N];\nset<int> leaf;\n\nvoid dfs(int cur, int depth, int d[]) {\n\tif (a[cur].size() == 1) {\n\t\tleaf.insert(cur);\n\t}\n\tfor (auto nn : a[cur]) {\n\t\tif (d[nn] > depth + 1) {\n\t\t\td[nn] = depth + 1;\n\t\t\tdfs(nn, depth + 1, d);\n\t\t}\n\t}\n}\n\nvoid input() {\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tl--;\n\t\tr--;\n\t\ta[l].push_back(r);\n\t\ta[r].push_back(l);\n\t}\n\tfor (int i = 0; i < 3; i++) {\n\t\tcin >> qs[i];\n\t\tqs[i]--;\n\t}\n}\n\nint solve() {\n\tinput();\n\tfill_n(d1, n, MAX);\n\tfill_n(d2, n, MAX);\n\tfill_n(d3, n, MAX);\n\td1[qs[0]] = 0;\n\tdfs(qs[0], 0, d1);\n\td2[qs[1]] = 0;\n\tdfs(qs[1], 0, d2);\n\td3[qs[2]] = 0;\n\tdfs(qs[2], 0, d3);\n\tfor (auto q : leaf) {\n\t\tif (d1[q] < d2[q] && d1[q] < d3[q]) {\n\t\t\tcout << \"YES\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"NO\\n\";\n\treturn 0;\n}\n\nint main() {\n\tFAST;\n\tsolve();\n\n\treturn 0;\n}\n```\n\n- dfs로 문제를 해결했다.\n- dfs를 3번 돌려서(윤이, 달구 그리고 포닉스) 각 위치별 최단 거리를 계산한 뒤($3N$) Leaf를 돌면서($N$) 윤이의 최단거리가 둘 보다 짧은 Leaf를 찾는다.\n- 결국 총 $4N$(입력 제외)로 문제를 해결할 것이다.\n- `set` 으로 Leaf를 저장했지만 시간 복잡도 상 $N$에 수렴한 기대값이다.\n\n## 개선 코드\n\n```python\nimport enum\nfrom sys import stdin, maxsize, setrecursionlimit\nfrom heapq import *\nfrom bisect import *\nfrom collections import deque\nimport random\nfrom itertools import combinations\n\nMAX = 17\nMOD = 1000000007\nsetrecursionlimit(10**6)\ninput = stdin.readline\n\nN = int(input())\na =[[] for _ in range(N+1)]\n\nfor _ in range(N-1):\n    l, r = map(int, input().split())\n    a[l].append(r)\n    a[r].append(l)\n\nqs = list(map(int, input().split()))\n\ndef main():\n    # ( pos, isYun: 1=yun, 2=others)\n    q = deque([(qs[1], 2), (qs[2], 2), (qs[0], 1)])\n    v = [0] * (N + 1) # v is visited array\n    v[qs[0]] = 1;v[qs[1]] = 2;v[qs[2]] = 2\n    while q:\n        pos, is_yun = q.popleft()\n        if is_yun == 1 and len(a[pos]) == 1:\n            print('YES');return;\n        for nn in a[pos]: # nn is next_node\n            if not v[nn]:\n                v[nn] = is_yun\n                q.append((nn, is_yun))\n    print('NO');return;\n    \n\nif __name__ == '__main__':\n    main()\n```\n\n- 굳이 $4N$으로 문제를 해결해야 할까? 여기서 시작된 생각이다.\n- 이 문제를 bfs로 다시 접근했다.\n- 처음 시작 queue에 달구, 포닉스 그리고 윤이 순으로 넣었다.\n    - 이유는 윤이가 첫번째로 들어갈 경우, 윤이의 어떤 노드까지 최단거리가 달구와 포닉스의 어떤 노드까지 최단거리와 같은 경우가 있기 때문이다.\n    - 따라서 먼저 달구와 포닉스가 방문한 노드는 윤이 입장에서 밟을 수 없는 노드가 된다. (해당 노드를 통해 진행된 leaf 노드까지 거리가 윤이는 달구와 포닉스보다 작을 수 없다)\n- 방문한 노드는 제외되기 때문에 전체 노드 개수 $N$만큼 while문이 진행될 것이다. 따라서 문제를 $N$으로 해결 할 수 있다.","fields":{"timeToRead":{"minutes":6.055},"slug":"/posts/2023-03-30/boj-27924/"},"internal":{"contentFilePath":"/home/runner/work/ha4219.github.io/ha4219.github.io/contents/posts/2023-03-30/boj-27924.mdx"}},"next":{"fields":{"slug":"/posts/2023-03-28/23-03-28/"}},"previous":{"fields":{"slug":"/posts/2023-04-03/boj-27896/"}}},{"node":{"frontmatter":{"title":"Hungarian Algorithm","date":"2022-08-01T00:00:00.000Z","moment":"8 months ago","thumbnail":null,"tags":["algorithm"],"category":"algorithm"},"excerpt":"아래 글 참조 Assignment Problem and Hungarian Algorithm\n\nProblem Statement\n\n가장 대표적으로 NN…","id":"1a1c4789-08b4-55f1-bdf0-7cec006845d1","body":"\n\n\n# Hungarian Algorithm\n\n> 아래 글 참조\n> \n> \n> [Assignment Problem and Hungarian Algorithm](https://www.topcoder.com/thrive/articles/Assignment%20Problem%20and%20Hungarian%20Algorithm)\n> \n\n<Callout>\n💡 call **out** test\n</Callout>\n\n## Problem Statement\n\n 가장 대표적으로 $N$명의 사람에게 $N$개의 일을 담당하는 문제를 생각해보자. 각 사람은 1개의 일을 담당할 수 있으며 이에 대한 $cost$가 발생한다. 그러면 기업 입장에서 목표는 이 비용을 최소화하며 $N$개의 일을 배치해야 한다. \n\n 아래는 위 설명을 식으로 설명한 것이다.\n\n$\\{c_{ij}\\}_{N\\times N}$: cost matrix, where $c_{ij}$: cost of $i$ to perform  job $j$.\n\n$\\{x_{ij}\\}_{N\\times N}$: resulting binary matrix, where $x_{ij} = 1$ if and only if $i_{th}$ worker is assigned to $j{th}$ job.\n\n$\\sum_{i=1}^{N}{x_{ij}} = 1$, $\\forall i\\in \\overline{1, N}$: one worker to one job assignment.\n\n$\\sum_{i=1}^{N}{x_{ij}} = 1$, $\\forall j\\in \\overline{1, N}$: one job to one worker assignment.\n\n$\\sum_{i=1}^N{\\sum_{j=1}^N{c_{ij}x_{ij}}} \\rightarrow min$: total cost function.\n\n우리는 이 문제를 그래프 문제로 바꿔 생각할 수 있다. $N$명의 사람에게 $N$개의 일에 대한 $cost$가 주어졌다고 생각하면 각 $N$명의 사람에게 $N$개의 일이 간선으로 연결되어 있어 총 $N*N$개의 간선이 연결된 그래프로 표현할 수 있다. 아래 예시를 보자.\n\n![Untitled](hungarian-algorithm/Untitled.png)\n\n## General Description Of The Algorithm\n\n이러한 문제를 할당문제라고 한다.\n\n이 문제를 foolish하게 해결하면 $O(n!)$이면 해결 할 수 있다. bfs, dfs로 순열을 찾고 이에 대한 cost를 계산해 최소값을 찾는다.\n\n쉽게 할 수 있지만 문제를 해결하기에 적합한 시간복잡도는 아니다.\n\n효율적인 방법의 알고리즘을 보여줄 텐데 하나는 쉽고 빠르게 $O(n^4)$이고 다른 하나는 구현이 복잡하지만 $O(n^3)$이다.\n\n## $O(n^4)$ Algorithm Explanation\n\n이분 그래프로 이 문제를 다루겠다. \n\n### Step 0)\n\n1. For each vertex from left part(workers) find the minimal outgoing edge and subtract its weight from all weights connected with this vertex. This will introduce 0-weight edges (at least one).\n2. Apply the same procedure for the vertices in the right part (jobs).\n\n![Untitled](hungarian-algorithm/Untitled-1.png)\n\n실제 이 순서는 필요하지 않지만 main cycle 수를 줄일 수 있다.\n\n### Step 1)\n\n1. Find the maximum matching using only 0-weight edges (for this purpose you can use max-flow algorithm, augmenting path algorithm, etc.).\n2. If it is perfect, then the problem is solved. Otherwise find the minimum vertex cover $V$(for the subgraph with 0-weight edges only), the best way to do this is to use [Köning’s graph theorem](http://www.topcoder.com/tc?module=LinkTracking&link=http://en.wikipedia.org/wiki/K%C3%B6nig%27s_theorem_(graph_theory)#proof&refer=hungarianAlgorithm).\n\n![Untitled](hungarian-algorithm/Untitled-2.png)\n\n### Step 2)\n\nLet $\\triangle min_{i \\notin V, j \\notin V}{c_{ij}}$ and adjust the weights using the following rule:\n\n![Untitled](hungarian-algorithm/Untitled-3.png)\n\n![Untitled](hungarian-algorithm/Untitled-4.png)\n\n### Step 3)\n\nRepeat Step 1 until solved.\n\nBut there is a nuance here; finding the maximum matching in step 1 on each iteration will cause the algorithm to become $O(n^5)$. In order to avoid this, on each step we can just modify the matching from the previous step, which only takes $O(n^2)$ operations.\n\nIt’s easy to see that no more than $n^2$ iterations will occur, because every time at least one edge becomes 0-weight. Therefore, the overall complexity is $O(n^4)$\n\n## $O(n^3)$ Algorithm Explanation","fields":{"timeToRead":{"minutes":3.385},"slug":"/posts/2022-08-01/hungarian-algorithm/"},"internal":{"contentFilePath":"/home/runner/work/ha4219.github.io/ha4219.github.io/contents/posts/2022-08-01/hungarian-algorithm.mdx"}},"next":{"fields":{"slug":"/posts/2022-01-20/test/"}},"previous":{"fields":{"slug":"/posts/2022-10-01/positional-embedding/"}}},{"node":{"frontmatter":{"title":"algorithm","date":"2022-01-22T01:55:00.000Z","moment":"a year ago","thumbnail":null,"tags":["boj"],"category":"algorithm"},"excerpt":"testtest","id":"ff8f90c4-ddf2-5866-a4f7-338582d855bb","body":"\n\n# test\n\n## testtest","fields":{"timeToRead":{"minutes":0.02},"slug":"/posts/2022-01-20/test/"},"internal":{"contentFilePath":"/home/runner/work/ha4219.github.io/ha4219.github.io/contents/posts/2022-01-20/test.mdx"}},"next":{"fields":{"slug":"/posts/2022-03-01/test-algorithm/"}},"previous":{"fields":{"slug":"/posts/2022-08-01/hungarian-algorithm/"}}},{"node":{"frontmatter":{"title":"test-algorithm","date":"2022-01-22T01:55:00.000Z","moment":"a year ago","thumbnail":"https://wikidocs.net/images/page/162976/FPN_2.png","tags":["boj"],"category":"algorithm"},"excerpt":"한글 작성 테스트한글 작성 테스트한글 작성 테스트한글 작성 테스트한글 작성 테스트한글 작성 테스트한글 작성 테스트한글 작성 테스트 // main.cpp\n\n#include…","id":"e9d5e299-c9e6-550e-a61c-9c19c50e2d84","body":"\n\n# algorithm 어렵다~~~~\n\n## 한글 작성 테스트한글 작성 테스트한글 작성 테스트한글 작성 테스트한글 작성 테스트한글 작성 테스트한글 작성 테스트한글 작성 테스트\n\n\n```cpp\n// main.cpp\n\n#include <iostream>\n\nint main() {\n  std::cout<<\"Hello World!\\n\";\n  return 0;\n}\n```\n\n\n$a=1$","fields":{"timeToRead":{"minutes":0.38},"slug":"/posts/2022-03-01/test-algorithm/"},"internal":{"contentFilePath":"/home/runner/work/ha4219.github.io/ha4219.github.io/contents/posts/2022-03-01/test-algorithm.mdx"}},"next":{"fields":{"slug":"/posts/2022-02-10/fpn/"}},"previous":{"fields":{"slug":"/posts/2022-01-20/test/"}}}]}},"staticQueryHashes":[],"slicesMap":{}}