{"componentChunkName":"component---src-templates-category-tsx","path":"/posts/algorithm/","result":{"pageContext":{"currentCategory":"algorithm","categories":["All","devops","vision","algorithm"],"edges":[{"node":{"frontmatter":{"title":"Hungarian Algorithm","date":"2022-08-01T00:00:00.000Z","moment":"5 months ago","thumbnail":null,"tags":["algorithm"],"category":"algorithm"},"excerpt":"아래 글 참조 Assignment Problem and Hungarian Algorithm\n\nProblem Statement\n\n가장 대표적으로 NN…","id":"cd85f833-f1fd-5414-a646-2d322e70f5bc","body":"\n\n\n# Hungarian Algorithm\n\n> 아래 글 참조\n> \n> \n> [Assignment Problem and Hungarian Algorithm](https://www.topcoder.com/thrive/articles/Assignment%20Problem%20and%20Hungarian%20Algorithm)\n> \n\n<Callout>\n💡 call **out** test\n</Callout>\n\n## Problem Statement\n\n 가장 대표적으로 $N$명의 사람에게 $N$개의 일을 담당하는 문제를 생각해보자. 각 사람은 1개의 일을 담당할 수 있으며 이에 대한 $cost$가 발생한다. 그러면 기업 입장에서 목표는 이 비용을 최소화하며 $N$개의 일을 배치해야 한다. \n\n 아래는 위 설명을 식으로 설명한 것이다.\n\n$\\{c_{ij}\\}_{N\\times N}$: cost matrix, where $c_{ij}$: cost of $i$ to perform  job $j$.\n\n$\\{x_{ij}\\}_{N\\times N}$: resulting binary matrix, where $x_{ij} = 1$ if and only if $i_{th}$ worker is assigned to $j{th}$ job.\n\n$\\sum_{i=1}^{N}{x_{ij}} = 1$, $\\forall i\\in \\overline{1, N}$: one worker to one job assignment.\n\n$\\sum_{i=1}^{N}{x_{ij}} = 1$, $\\forall j\\in \\overline{1, N}$: one job to one worker assignment.\n\n$\\sum_{i=1}^N{\\sum_{j=1}^N{c_{ij}x_{ij}}} \\rightarrow min$: total cost function.\n\n우리는 이 문제를 그래프 문제로 바꿔 생각할 수 있다. $N$명의 사람에게 $N$개의 일에 대한 $cost$가 주어졌다고 생각하면 각 $N$명의 사람에게 $N$개의 일이 간선으로 연결되어 있어 총 $N*N$개의 간선이 연결된 그래프로 표현할 수 있다. 아래 예시를 보자.\n\n![Untitled](hungarian-algorithm/Untitled.png)\n\n## General Description Of The Algorithm\n\n이러한 문제를 할당문제라고 한다.\n\n이 문제를 foolish하게 해결하면 $O(n!)$이면 해결 할 수 있다. bfs, dfs로 순열을 찾고 이에 대한 cost를 계산해 최소값을 찾는다.\n\n쉽게 할 수 있지만 문제를 해결하기에 적합한 시간복잡도는 아니다.\n\n효율적인 방법의 알고리즘을 보여줄 텐데 하나는 쉽고 빠르게 $O(n^4)$이고 다른 하나는 구현이 복잡하지만 $O(n^3)$이다.\n\n## $O(n^4)$ Algorithm Explanation\n\n이분 그래프로 이 문제를 다루겠다. \n\n### Step 0)\n\n1. For each vertex from left part(workers) find the minimal outgoing edge and subtract its weight from all weights connected with this vertex. This will introduce 0-weight edges (at least one).\n2. Apply the same procedure for the vertices in the right part (jobs).\n\n![Untitled](hungarian-algorithm/Untitled-1.png)\n\n실제 이 순서는 필요하지 않지만 main cycle 수를 줄일 수 있다.\n\n### Step 1)\n\n1. Find the maximum matching using only 0-weight edges (for this purpose you can use max-flow algorithm, augmenting path algorithm, etc.).\n2. If it is perfect, then the problem is solved. Otherwise find the minimum vertex cover $V$(for the subgraph with 0-weight edges only), the best way to do this is to use [Köning’s graph theorem](http://www.topcoder.com/tc?module=LinkTracking&link=http://en.wikipedia.org/wiki/K%C3%B6nig%27s_theorem_(graph_theory)#proof&refer=hungarianAlgorithm).\n\n![Untitled](hungarian-algorithm/Untitled-2.png)\n\n### Step 2)\n\nLet $\\triangle min_{i \\notin V, j \\notin V}{c_{ij}}$ and adjust the weights using the following rule:\n\n![Untitled](hungarian-algorithm/Untitled-3.png)\n\n![Untitled](hungarian-algorithm/Untitled-4.png)\n\n### Step 3)\n\nRepeat Step 1 until solved.\n\nBut there is a nuance here; finding the maximum matching in step 1 on each iteration will cause the algorithm to become $O(n^5)$. In order to avoid this, on each step we can just modify the matching from the previous step, which only takes $O(n^2)$ operations.\n\nIt’s easy to see that no more than $n^2$ iterations will occur, because every time at least one edge becomes 0-weight. Therefore, the overall complexity is $O(n^4)$\n\n## $O(n^3)$ Algorithm Explanation","fields":{"timeToRead":{"minutes":3.385},"slug":"/posts/2022-08-01/hungarian-algorithm/"},"internal":{"contentFilePath":"/Users/jeongdongha/code/toy/ha4219.github.io/contents/posts/2022-08-01/hungarian-algorithm.mdx"}},"next":{"fields":{"slug":"/posts/2022-03-01/test-algorithm/"}},"previous":{"fields":{"slug":"/posts/2022-10-01/positional-embedding/"}}},{"node":{"frontmatter":{"title":"test-algorithm","date":"2022-01-22T01:55:00.000Z","moment":"a year ago","thumbnail":"https://wikidocs.net/images/page/162976/FPN_2.png","tags":["boj"],"category":"algorithm"},"excerpt":"한글 작성 테스트한글 작성 테스트한글 작성 테스트한글 작성 테스트한글 작성 테스트한글 작성 테스트한글 작성 테스트한글 작성 테스트 // main.cpp\n\n#include…","id":"f054da06-05b0-546c-ab11-0bfd200f2926","body":"\n\n# algorithm 어렵다~~~~\n\n## 한글 작성 테스트한글 작성 테스트한글 작성 테스트한글 작성 테스트한글 작성 테스트한글 작성 테스트한글 작성 테스트한글 작성 테스트\n\n\n```cpp\n// main.cpp\n\n#include <iostream>\n\nint main() {\n  std::cout<<\"Hello World!\\n\";\n  return 0;\n}\n```\n\n\n$a=1$","fields":{"timeToRead":{"minutes":0.38},"slug":"/posts/2022-03-01/test-algorithm/"},"internal":{"contentFilePath":"/Users/jeongdongha/code/toy/ha4219.github.io/contents/posts/2022-03-01/test-algorithm.mdx"}},"next":{"fields":{"slug":"/posts/2022-01-20/test/"}},"previous":{"fields":{"slug":"/posts/2022-08-01/hungarian-algorithm/"}}},{"node":{"frontmatter":{"title":"algorithm","date":"2022-01-22T01:55:00.000Z","moment":"a year ago","thumbnail":null,"tags":["boj","bojbojbojbojbojbojbojbojbojbojbojbojboj","boj","boj","boj","boj","boj","boj","boj","boj","boj","bojbojbojbojbojbojbojbojbojbojbojbojbojbojbojboj"],"category":"algorithm"},"excerpt":"testtest","id":"cc9b011d-9836-5741-bb74-70d9aa2a7a9c","body":"\n\n# test\n\n## testtest","fields":{"timeToRead":{"minutes":0.02},"slug":"/posts/2022-01-20/test/"},"internal":{"contentFilePath":"/Users/jeongdongha/code/toy/ha4219.github.io/contents/posts/2022-01-20/test.mdx"}},"next":{"fields":{"slug":"/posts/2022-02-10/fpn/"}},"previous":{"fields":{"slug":"/posts/2022-03-01/test-algorithm/"}}}]}},"staticQueryHashes":[],"slicesMap":{}}